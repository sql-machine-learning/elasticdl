## Audience Targets

ElasticDL targets two categories of users

1. *Modelers*, those who create new models, including deep learning researchers and engineers, and
1. SQLFlow users.

The high-level API must meet the requirements of these users.

## User Expectations

### Modelers

Modelers usually craft their Keras models on their personal computers, test the model with small datasets, and would like to file a distributed training job with big datasets on the cloud.

Suppose that one is working on a model in the local directory `$HOME/work/fintech/*.py`, where each `.py` file might contain one ore more Keras model classes. We would love to allow the user to submit an ElasticDL training job from the command-line like the following to train a model defined as a class `MyKerasModel`.

```bash
elasticdl train \
    --model_zoo=$HOME/work \
    --model=fintech.MyKerasModel \
    --input_fn=fintech.image_label_input \
    --params='hidden_units=[10, 100, 20, 5], learning_rate=0.01' \
    --data='/filestore/yiwang/imagenet/train/*.recordio' \
    --output='/filestore/yiwang/mykerasmodelparams'
```

The above command-line 

1. builds a Docker image containing (1) `$HOME/work` mapped to `/model_zoo/custom`, (2) ElasticDL, (3) dependencies of ElasticDL,
1. submits an ElasticDL job to the Kubernetes cluster as described in `$HOME/.kube/config`,
1. prints an URL to the dashboard so users could inspect the progress/status of the job in the user's Web browser.

Please be aware that in the class `fintech.MyKerasModel`, in addition to overriding the method `call`, we also need to provide methods like

- `default_loss` that returns a loss operator,
- `default_optimizer` that returns an optimizer operator,
- `default_input` that takes a record (string) as its input and returns something that can be batched and consumed by `MyKerasModel.call`.  In the above example, the user chooses an input function other than `MyKerasModel.default_input`.

Another important command-line is to support prediction.

```bash
elasticdl predict \
    --data='/filestore/yiwang/imagenet/test/*.recordio' \
    --trained_model='/filestore/yiwang/mykerasmodelparams' \
    --output='/filestore/yiwang/imagenet-eval.recordio'
```

### SQLFlow Users

SQLFlow users provide the information required by training or prediction by writing a SQL statement with extended syntax.  The syntax for training extends the SELECT statement with the TRAIN clause.  For example:

```sql
SELECT name, role, salary FROM employee 
TRAIN DNNClassifier 
WITH hidden_units=[10, 100, 20, 5], learning_rate=0.01
INTO mymodel;
```

Please be aware that to minimize the syntax extension, SQLFlow doesn't allow users to specify a directory of models; instead, users can only use pre-released models, for example, `DNNClassifier` in the above example.

SQLFlow is a gRPC server that takes the above SQL statement and translates it into a Python program known as a *submitter*.  It is the responsibility of the submitter to call `kubectl` and launch an ElasticDL job on a Kubernetes cluster.

SQLFlow often runs in Docker containers, and it is usually intractable to build a Docker image from within a Docker container, so the submitter requires a pre-built Docker image containing (1) `/model_zoo`, (2) ElasticDL, (3) dependencies of ElasticDL.  The class `DNNClassifier` is a class defined in some Python source files in `/model_zoo`.

The submitter might file the statement `SELECT name, role, salary FROM employee` to the SQL engine, pull the result, convert the result into one or more RecordIO files whose each record is a serialization of the `tf.Example` protobuf message. So, the input function used by ElasticDL to parse the strings for `DNNClassifer.class` could be standardized one, say, `sqlflow.elasticdl_input_function`.

To predict using a pre-trained model and writes the results into a column of some table, we can do

```sql
SELECT name, role FROM testdata
PREDICT testdata.predicted_salary
USING mymodel;
```

### Unified API

Both the command line tool `elasticdl` provided for modelers and the submitter program generated by SQLFlow need to call an API that launches ElasticDL jobs.  Hence this design.

## API

We hope the ElasticDL API supports not only batch learning, but also online learning, adversarial learning, reinforcement learning, and federated learning.  However, at the right moment, let us start with batch learning.

### For Training

We propose a function `elastic.train` that can be called like the following:

```python
elasticdl.train(
    model_zoo="$HOME/work",
    model_class="fintech.MyKerasModel", 
    input_fn="fintech.image_label_input",
    params="hidden_units=[10, 100, 20, 5], learning_rate=0.01",
    data="/filestore/yiwang/imagenet/train/*.recordio",
    output="/filestore/yiwang/mykerasmodelparams")
```

or

```python
elasticdl.train(
    model_zoo="https://github.com/sql-machine-learning/models",
    model_class="regressor.DNN", 
    input_fn="sqlflow.elasticdl_input_function',
    params="hidden_units=[10, 100, 20, 5], learning_rate=0.01",
    data="/tmp/sqlflow-pulled-from-sql/job-xxyyzz/*.recordio",
    output="/sqlflow-configured-place/job-xxyyzz/mymodel")
```

Please be aware that most parameters of `elasticdl.train` are of string-type because the command line options and SQL statements are all strings.

### For Prediction

```python
elasticdl.predict(
    data='/filestore/yiwang/imagenet/test/*.recordio',
    trained_model='/filestore/yiwang/mykerasmodelparams',
    output='/filestore/yiwang/imagenet-eval.recordio')
```

```python
elasticdl.predict(
    data="/tmp/sqlflow-pulled-from-sql/job-xxyyzz/*.recordio",
    trained_model='/filestore/yiwang/mykerasmodelparams',
    output='/tmp/sqlflow-output/job-xxyyzz.recordio')
```

## Model Zoo

When the ElasticDL client or the SQLFlow server call `elasticdl.train`, this function calls Docker API to build a Docker image then submits the job.  The building process should add a *model zoo* into the Docker image.  The function `elasticdl.train` has a parameter, which could be the following cases:

1. A local directory, for example,

   ```python
   elasticdl.train(model_zoo="a_local_directory", ...)
   ```
   
1. A URL pointing to a Git repo

   ```python
   elasticdl.train(model_zoo="https://username:password@git.somecompany.com/sql-machine-learning/models", ...)
   ```

A model zoo is a plain Python source directory that's added to `/model_zoo` in the Docker image.

In the root directory there requires a `requirements.txt` file, so the image building process can call `pip install -r /model_zoo/requirements.txt` to install the dependencies.

Suppose that a Keras model class is referred to as `regressor.DNN` in `elasticdl.train(model_class="regressor.DNN",`, the corresponding Python file should be `/model_zoo/regressor.py`.  A class `regressor.wide_and_deep.MagicalWAD` is in a Python file `/model_zoo/regressor/wide_and_deep.py`.
